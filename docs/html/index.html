<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libschc: libschc: A C implementation of the Static Context Header Compression</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libschc
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">libschc: A C implementation of the Static Context Header Compression </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1"></a>
ABOUT LIBSCHC</h1>
<p>libschc is a C implementation of the Static Context Header Compression, drafted by the IETF. It is a header compression technique, used in Low Power Wide Area Networks in order to enable tiny low-power microcontrollers to have an end-to-end IPv6 connection. This repository contains both the compression aswell as the fragmentation mechanism. For further information related to SCHC, see <a href="https://datatracker.ietf.org/doc/draft-ietf-lpwan-ipv6-static-context-hc/">https://datatracker.ietf.org/doc/draft-ietf-lpwan-ipv6-static-context-hc/</a>.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
LIMITATIONS</h1>
<p>As this implementation is work in progress, there are some limitations you should keep in mind. The library has been designed in such a way, that it can be used on top of a constrained device, as well as on a more powerful server side device. As a consequence, memory allocation and memory intensive calculations are avoided. I tended to use fixed point arithmetic for 8-bit mircoprocessors, however some optimizations are possible.</p>
<p>The <code>schc-config.h</code> file contains a definition for dynamic memory allocation, used by fragmenter.</p>
<p>The current implementation is based on draft-ietf-lpwan-ipv6-static-context-hc-18 (<a href="https://datatracker.ietf.org/doc/draft-ietf-lpwan-ipv6-static-context-hc/18/">https://datatracker.ietf.org/doc/draft-ietf-lpwan-ipv6-static-context-hc/18/</a>), some naming conventions are therefore not in line with the current specification.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
DOCUMENTATION</h1>
<h2><a class="anchor" id="autotoc_md4"></a>
Configuration</h2>
<p>First copy the configuration file </p><div class="fragment"><div class="line">mv schc_config_example.h schc_config.h</div>
</div><!-- fragment --><p> and edit the definitions according to your platform.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Rules</h2>
<p>As the rules tend to consume a large part of memory, and</p>
<p>Currently, I only have been working with rules for a single device. However, as the server application will have to keep track of multiple devices, this should be implemented in a decoupled way. The rules are implemented in a layered fashion and should be combined with a rule map to use different layers in a single ID. This map could then be reused for different devices.</p>
<p>In <code><a class="el" href="rules_8h.html">rules.h</a></code>, several rules can be defined </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structschc__rule.html">schc_rule</a> {</div>
<div class="line">    uint16_t <a class="code" href="structschc__rule.html#afd8204c9d5c8d9262ce77ff417322b3c">rule_id</a>;</div>
<div class="line">    uint8_t <a class="code" href="structschc__rule.html#a514775672b0343784cda603a5ec4e61c">up</a>;</div>
<div class="line">    uint8_t <a class="code" href="structschc__rule.html#aead6af025477ce0b7c180b9df5091057">down</a>;</div>
<div class="line">    uint8_t <a class="code" href="structschc__rule.html#af5f20076e164f0bbeaf3f2fbbab1ee78">length</a>;</div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="structschc__field.html">schc_field</a> <a class="code" href="structschc__rule.html#a8f5dabb53d4bd4cfa409a2b56faef7d0">content</a>[<a class="code" href="schc__config_8h.html#af1690024e8fe24a690d86ec4dd5d3bb6">COAP_FIELDS</a>];</div>
<div class="line">};</div>
</div><!-- fragment --><p> Where the number of fields with Field Direction UP and DOWN are set and the total number of fields in the rule The rule is therefore constructed of different <code><a class="el" href="structschc__field.html">schc_field</a></code>: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structschc__field.html">schc_field</a> {</div>
<div class="line">    <span class="keywordtype">char</span> <a class="code" href="structschc__field.html#a95686cf98fe8ea0e3e613fc7b3543a9c">field</a>[32];</div>
<div class="line">    uint8_t <a class="code" href="structschc__field.html#a29edf1bbed3c31adec3a364ab55389ed">msb_length</a>;</div>
<div class="line">    uint8_t <a class="code" href="structschc__field.html#a935adff07534f10568676ffa884ea4aa">field_length</a>;</div>
<div class="line">    uint8_t <a class="code" href="structschc__field.html#af44027e5add508a163aef5a0898bbb15">field_pos</a>;</div>
<div class="line">    <a class="code" href="config_8h.html#a99f26e6ee9fcd62f75203b5402df8098">direction</a> <a class="code" href="structschc__field.html#a23f0e54fa507136cff38e313b3f064cb">dir</a>;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="structschc__field.html#ac630b87f129d988ad5d18d2f22375354">target_value</a>[<a class="code" href="schc__config_8h.html#aa6420ecddb30151dd25bc1a2da3aacd1">MAX_COAP_FIELD_LENGTH</a>];</div>
<div class="line">    uint8_t (*<a class="code" href="structschc__field.html#ae2dd6faff6388e1b0b4ecd973ebbd4af">MO</a>)(<span class="keyword">struct </span><a class="code" href="structschc__field.html">schc_field</a>* target_field, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* field_value);</div>
<div class="line">    <a class="code" href="config_8h.html#a3e43f38d5254d1e3bbf1d0955eb98ce4">CDA</a> <a class="code" href="structschc__field.html#a53b37bd9de93614e76640174cffa11fa">action</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><ul>
<li><code>field</code> holds a string of the field name (i.e. the human-readability of the rules).</li>
<li>the <code>msb_length</code> is used in combination with the Matching Operator <code>MSB</code>, but should be removed in coming releases.</li>
<li>the <code>field_length</code> indicates the length of <b>bytes</b>, but should be bits in coming releases. Field Position is only used for headers where multiple fields can exist for the same entry (e.g. CoAP uri-path).</li>
<li><code>dir</code> indicates the direction (<code>UP</code>, <code>DOWN</code> or <code>BI</code>) and will have an impact on how the rules behave while compressing/decompressing. Depending on the <code>#define SERVER</code> in <code><a class="el" href="schc__config_8h.html">schc_config.h</a></code>, the source and destination in the <code>decompress_ipv6_rule</code> and <code>generate_ip_header_fields</code> will be swapped, to ensure a single rule for server and end device.</li>
<li><code>target_value</code> holds a <code>char</code> array in order to support larger values. The downside of this approach is the <code>MAX_COAP_FIELD_LENGTH</code> definition, which should be set to the largest defined Target Value in order to save as much memory as possible.</li>
<li>the <code>MO</code> is a pointer to the Matching Operator functions (defined in <code><a class="el" href="config_8h.html">config.h</a></code>)</li>
<li><code>CDA</code> contains the Compression/Decompression action (<code>enum</code> in <code><a class="el" href="config_8h.html">config.h</a></code>)</li>
</ul>
<p>Once all the rules are set up for a device, these can be saved and added to the device definition </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structschc__device.html">schc_device</a> {</div>
<div class="line">    uint32_t <a class="code" href="structschc__device.html#a5f22593142303b2722a0b9fb4167949e">id</a>;</div>
<div class="line">    uint8_t <a class="code" href="structschc__device.html#a5083555c2c2ccf7596ff712a5f553164">ipv6_count</a>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structschc__rule.html">schc_rule</a>* <a class="code" href="structschc__device.html#a48b4d7fc260918b615608790b7913fcc">ipv6_rules</a>;</div>
<div class="line">    uint8_t <a class="code" href="structschc__device.html#a15834e0951fb90004fc75760cc43109a">udp_count</a>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structschc__rule.html">schc_rule</a>* <a class="code" href="structschc__device.html#a29183298f7685ea9e6e88e0f72902b9c">udp_rules</a>;</div>
<div class="line">    uint8_t <a class="code" href="structschc__device.html#ad2762cbab006c80cc2ffebe131e327ea">coap_count</a>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structschc__rule.html">schc_rule</a>* <a class="code" href="structschc__device.html#a2a3b02f0e0c66aea96fb08a64fa8b77f">coap_rules</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> This is all done very statically and needs further enhancements.</p>
<p>The <code><a class="el" href="rules_8h.html">rules.h</a></code> file should contain enough information to try out different settings.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Compressor</h2>
<p>The compressor performs all actions to compress the given protocol headers. First, the compressesor should be initialized with the node it's source IP address (8 bit array): </p><div class="fragment"><div class="line">uint8_t <a class="code" href="compressor_8c.html#a4fd03f3acd56b4bf55fc4c8e48567ab7">schc_compressor_init</a>(uint8_t src[16]);</div>
</div><!-- fragment --><p>In order to compress a CoAP/UDP/IP packet, the following function can be called. This requires a buffer (<code>uint8_t *buf</code>) to which the compressed packet may be returned. </p><div class="fragment"><div class="line">int16_t <a class="code" href="compressor_8c.html#abd42f4bd7b7fdd8ea7b4c3504720a0ea">schc_compress</a>(<span class="keyword">const</span> uint8_t *data, uint8_t* buf, uint16_t total_length);</div>
</div><!-- fragment --><p>The reverse can be done by calling: </p><div class="fragment"><div class="line">uint16_t <a class="code" href="compressor_8c.html#a48ebb52c79106c2a7658a513c2a65463">schc_construct_header</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* data, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *header,</div>
<div class="line">    uint32_t device_id, uint16_t total_length, uint8_t *header_offset);</div>
</div><!-- fragment --><p> This requires a buffer to which the decompressed headers can be returned (<code>unsigned char *header</code>), a pointer to the complete original data packet (<code>unsigned char *data</code>), the device id and total length and finally a pointer to an integer (<code>uint8_t *header_offset</code>), which will return the compressed header size (i.e. the position in the buffer where the actual data starts). The function will return the decompressed header length.</p>
<p>Once the decompressed packet has been constructed, the UDP length and checksum may be calculated (this is still an open issue, as these functions should be called from the <code>construct_header</code> function itself). </p><div class="fragment"><div class="line">uint16_t <a class="code" href="compressor_8c.html#a650a861e13b9cb68043df5319d83b92d">compute_length</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data, uint16_t data_len);</div>
<div class="line">uint16_t <a class="code" href="compressor_8c.html#a89368d1a9e14855697684aa89b0f1aac">compute_checksum</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data);</div>
</div><!-- fragment --><p>The result should be a complete decompressed packet.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Fragmenter</h2>
<p>The fragmenter and compressor are decoupled and require seperate initialization. </p><div class="fragment"><div class="line">int8_t <a class="code" href="fragmenter_8c.html#a8d563c2c366a59b52ae25123a38c7603">schc_fragmenter_init</a>(<a class="code" href="structschc__fragmentation__t.html">schc_fragmentation_t</a>* tx_conn, </div>
<div class="line">        <span class="keywordtype">void</span> (*send)(uint8_t* data, uint16_t <a class="code" href="structschc__rule.html#af5f20076e164f0bbeaf3f2fbbab1ee78">length</a>, uint32_t device_id),</div>
<div class="line">        <span class="keywordtype">void</span> (*end_rx)(<a class="code" href="structschc__fragmentation__t.html">schc_fragmentation_t</a>* conn),</div>
<div class="line">        <span class="keywordtype">void</span> (*remove_timer_entry)(uint32_t device_id))</div>
</div><!-- fragment --><p> The initilization function takes the following arguments:</p><ul>
<li><code>tx_conn</code>, which can be an empty <code><a class="el" href="structschc__fragmentation__t.html">schc_fragmentation_t</a></code> struct, to hold the information of the sending device.</li>
<li><code>send</code> requires a pointer to a callback function, which will transmit the fragment over any interface and requires a platform specific implementation</li>
<li><code>end_rx</code> is called once the complete packet has been received (more information bellow)</li>
<li><code>remove_timer_entry</code> had to be added for some platforms to remove timers once the complete transmission has been completed</li>
</ul>
<h3><a class="anchor" id="autotoc_md8"></a>
mbuf</h3>
<p>The fragmenter is built around the <code>mbuf</code> principle, derived from the BSD OS, where every fragment is part of a linked list. The fragmenter holds a preallocated number of slots, defined in <code><a class="el" href="schc__config_8h.html">schc_config.h</a></code> with <code>#define SCHC_CONF_RX_CONNS</code>. Every received packet is added to the <code>MBUF_POOL</code>, containing a linked list of fragments for a particular connection. Once a transmission has been ended, the fragmenter will then glue together the different fragments.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Reassembly</h3>
<p>Upon reception of a fragment, the following function should be called: </p><div class="fragment"><div class="line"><a class="code" href="structschc__fragmentation__t.html">schc_fragmentation_t</a>* <a class="code" href="fragmenter_8c.html#a0fac20e73f52464091a717bde243deb3">schc_input</a>(uint8_t* data, uint16_t len, <a class="code" href="structschc__fragmentation__t.html">schc_fragmentation_t</a>* tx_conn, uint32_t device_id)</div>
</div><!-- fragment --><ul>
<li>the <code>tx_conn</code> structure is used to check if the received frame was an acknowledgment and will return the <code>tx_conn</code> if so</li>
<li>the <code>device_id</code> is used to find out if the current device is involved in an ongoing transmission and will return the <code>rx_conn</code> if so</li>
</ul>
<p>These return values can be used in the application to perform corresponding actions, e.g: </p><div class="fragment"><div class="line">uint8_t ret = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (conn != &amp;tx_conn) {</div>
<div class="line">    conn-&gt;<a class="code" href="structschc__fragmentation__t.html#ab0679bb4a377f6ce9da82769cf88c52c">mode</a> = <a class="code" href="fragmenter_8h.html#a00b61f9b90ab7065eb6a978141d7fd34a0344f277cbdd16e3f0ea0ff1d1be1b17">NO_ACK</a>;<span class="comment">// todo get from rule</span></div>
<div class="line">    <span class="keywordflow">if</span>(conn-&gt;<a class="code" href="structschc__fragmentation__t.html#ab0679bb4a377f6ce9da82769cf88c52c">mode</a> == <a class="code" href="fragmenter_8h.html#a00b61f9b90ab7065eb6a978141d7fd34a0344f277cbdd16e3f0ea0ff1d1be1b17">NO_ACK</a>) { <span class="comment">// todo get from rule</span></div>
<div class="line">        conn-&gt;<a class="code" href="structschc__fragmentation__t.html#af72b38948d4bb6fbc0a261cd092ddd10">FCN_SIZE</a> = 1;</div>
<div class="line">        conn-&gt;<a class="code" href="structschc__fragmentation__t.html#a5233caff42cce7f50dd5279b9d838400">WINDOW_SIZE</a> = 0;</div>
<div class="line">    }</div>
<div class="line">    conn-&gt;<a class="code" href="structschc__fragmentation__t.html#af54664c2e4cfb10cc250896f070f6d5b">post_timer_task</a> = &amp;set_rx_timer;</div>
<div class="line">    conn-&gt;<a class="code" href="structschc__fragmentation__t.html#ac3fbcae2ee4198df9d04438d63d97361">dc</a> = 50000; <span class="comment">// duty cycle</span></div>
<div class="line">    ret = <a class="code" href="fragmenter_8c.html#a6a248f74b7a8b0ef5f7dbc3f418e05a8">schc_reassemble</a>(conn);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(ret == 1) { <span class="comment">// reception finished</span></div>
<div class="line">    packet_to_ip6(conn);</div>
<div class="line">}</div>
</div><!-- fragment --><p> The above example is application code of the server, receiving a compressed, fragmented packet. By calling <code>schc_reassemble</code>, the fragmenter will take care of adding fragments to the <code>MBUF_POOL</code>.</p>
<p>Once the reception is finished, <code>packet_to_ip6</code> is called, where the <code>mbuf</code> can be reassembled to a regular packet. First we want to get the length of the packet: </p><div class="fragment"><div class="line">uint16_t <a class="code" href="fragmenter_8c.html#a974581b10381381bafe401fc2ddc54c7">get_mbuf_len</a>(<a class="code" href="structschc__mbuf__t.html">schc_mbuf_t</a> *head); <span class="comment">// call with conn-&gt;head as argument</span></div>
</div><!-- fragment --><p> Next, a buffer can be allocated with the appropriate length (the return value of <code>get_mbuf_len</code>). The reassmbled packet can then be copied to the pointer passed to the following function: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="fragmenter_8c.html#a3b3e7a45b2ff0f407adfcc266f47c3dc">mbuf_copy</a>(<a class="code" href="structschc__mbuf__t.html">schc_mbuf_t</a> *head, uint8_t* ptr); <span class="comment">// call with conn-&gt;head and pointer to allocated buffer</span></div>
</div><!-- fragment --><p> The result will be a compressed packet, which can be decompressed by using the decompressor.</p>
<p>Don't forget to reset the connection. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="fragmenter_8c.html#af04b125eaaa72e66f782bdb592133a27">schc_reset</a>(<a class="code" href="structschc__fragmentation__t.html">schc_fragmentation_t</a>* conn);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md10"></a>
Fragmentation</h3>
<p>After compressing a packet, the return value of <code>schc_compress</code> can be used to check whether a packet should be fragmented or not. In order to fragment a packet, the parameters of the connection should be set according to your preferences.</p>
<div class="fragment"><div class="line">tx_conn.<a class="code" href="structschc__fragmentation__t.html#ab0679bb4a377f6ce9da82769cf88c52c">mode</a> = <a class="code" href="fragmenter_8h.html#a00b61f9b90ab7065eb6a978141d7fd34abb669910db44bb35ca22cfa0987cff5f">ACK_ON_ERROR</a>;</div>
<div class="line">tx_conn.<a class="code" href="structschc__fragmentation__t.html#aacb88301231fdf7ebf596250d3b75201">mtu</a> = current_network_driver-&gt;mtu; <span class="comment">// the maximum length of each fragment</span></div>
<div class="line">tx_conn.<a class="code" href="structschc__fragmentation__t.html#ac3fbcae2ee4198df9d04438d63d97361">dc</a> = 20000; <span class="comment">// duty cycle</span></div>
<div class="line"> </div>
<div class="line">tx_conn.<a class="code" href="structschc__fragmentation__t.html#a54c6634755f3b9737e8c61d0fdea3a37">data_ptr</a> = &amp;compressed_packet; <span class="comment">// the pointer to the compressed packet</span></div>
<div class="line">tx_conn.<a class="code" href="structschc__fragmentation__t.html#a81a06b0db6f570800959533e1fd2ce58">packet_len</a> = err; <span class="comment">// the total length of the packet</span></div>
<div class="line">tx_conn.<a class="code" href="structschc__fragmentation__t.html#a0d771b7ddff550f4e30b238f1a332572">send</a> = &amp;network_driver_send; <span class="comment">// callback function to call for transmission</span></div>
<div class="line">tx_conn.<a class="code" href="structschc__fragmentation__t.html#af72b38948d4bb6fbc0a261cd092ddd10">FCN_SIZE</a> = 3; <span class="comment">// todo get from rule</span></div>
<div class="line">tx_conn.<a class="code" href="structschc__fragmentation__t.html#af8670ae896636ff443e1079940ba018c">MAX_WND_FCN</a> = 6; <span class="comment">// todo will be removed?</span></div>
<div class="line">tx_conn.<a class="code" href="structschc__fragmentation__t.html#a5233caff42cce7f50dd5279b9d838400">WINDOW_SIZE</a> = 1; <span class="comment">// todo support multiple window sizes</span></div>
<div class="line">tx_conn.<a class="code" href="structschc__fragmentation__t.html#a815c8ccfa3da28a4140d60ff5e9e7b17">DTAG_SIZE</a> = 0; <span class="comment">// todo no support yet</span></div>
<div class="line">tx_conn.<a class="code" href="structschc__fragmentation__t.html#a8a6c636f8d863fc3db680da64ee889c1">RULE_SIZE</a> = 8; <span class="comment">// todo get from rule</span></div>
<div class="line"> </div>
<div class="line">tx_conn.<a class="code" href="structschc__fragmentation__t.html#af54664c2e4cfb10cc250896f070f6d5b">post_timer_task</a> = &amp;set_tx_timer;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="fragmenter_8c.html#a5c375e7b44652a0eccb9248083a6251d">schc_fragment</a>((<a class="code" href="structschc__fragmentation__t.html">schc_fragmentation_t</a>*) &amp;tx_conn); <span class="comment">// start the fragmentation</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md11"></a>
Timers</h3>
<p>As you can see in the above examples, the library has no native support for timers and requires callback functions from the main application to schedule transmissions and to time out. Therefore, 2 function callbacks are required. The following is based on the OSS-7 platform. </p><div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * The timer used by the SCHC library to schedule the transmission of fragments</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> set_tx_timer(<span class="keywordtype">void</span> (*callback)(<span class="keywordtype">void</span>* conn), uint32_t device_id, uint32_t delay, <span class="keywordtype">void</span> *arg) {</div>
<div class="line">    timer_post_task_prio(callback, timer_get_counter_value() + delay, DEFAULT_PRIORITY, arg);</div>
<div class="line">}</div>
</div><!-- fragment --><p>As the server has to keep track of multiple devices and connections, a vector is used to keep track of multiple devices. The following is part of a C++ implementation, which makes use of the C library. </p><div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * The timer used by the SCHC library to time out the reception of fragments</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> set_rx_timer(<span class="keywordtype">void</span> (*callback)(<span class="keywordtype">void</span>* conn), uint32_t device_id, uint32_t delay, <span class="keywordtype">void</span> *arg) {</div>
<div class="line">    add_device(device_id, delay, callback);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md12"></a>
LICENSE</h1>
<p>Licensed under the GNU General Public License, Version 3 (the "License"): You may not use these files except in compliance with the License. You may obtain a copy of the License at <a href="https://www.gnu.org/licenses/gpl-3.0.nl.html">https://www.gnu.org/licenses/gpl-3.0.nl.html</a></p>
<p>See the License for the specific language governing permissions and limitations under the License.</p>
<p>Â© Copyright 2018-2019, Bart Moons <a href="#" onclick="location.href='mai'+'lto:'+'bam'+'oo'+'ns.'+'mo'+'ons'+'@u'+'gen'+'t.'+'be'; return false;">bamoo<span style="display: none;">.nosp@m.</span>ns.m<span style="display: none;">.nosp@m.</span>oons@<span style="display: none;">.nosp@m.</span>ugen<span style="display: none;">.nosp@m.</span>t.be</a> and Ghent University </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="ttc" id="astructschc__field_html_ae2dd6faff6388e1b0b4ecd973ebbd4af"><div class="ttname"><a href="structschc__field.html#ae2dd6faff6388e1b0b4ecd973ebbd4af">schc_field::MO</a></div><div class="ttdeci">uint8_t(* MO)(struct schc_field *target_field, unsigned char *field_value)</div><div class="ttdef"><b>Definition:</b> config.h:44</div></div>
<div class="ttc" id="astructschc__rule_html_a514775672b0343784cda603a5ec4e61c"><div class="ttname"><a href="structschc__rule.html#a514775672b0343784cda603a5ec4e61c">schc_rule::up</a></div><div class="ttdeci">uint8_t up</div><div class="ttdef"><b>Definition:</b> config.h:54</div></div>
<div class="ttc" id="afragmenter_8h_html_a00b61f9b90ab7065eb6a978141d7fd34a0344f277cbdd16e3f0ea0ff1d1be1b17"><div class="ttname"><a href="fragmenter_8h.html#a00b61f9b90ab7065eb6a978141d7fd34a0344f277cbdd16e3f0ea0ff1d1be1b17">NO_ACK</a></div><div class="ttdef"><b>Definition:</b> fragmenter.h:54</div></div>
<div class="ttc" id="astructschc__fragmentation__t_html_a815c8ccfa3da28a4140d60ff5e9e7b17"><div class="ttname"><a href="structschc__fragmentation__t.html#a815c8ccfa3da28a4140d60ff5e9e7b17">schc_fragmentation_t::DTAG_SIZE</a></div><div class="ttdeci">uint8_t DTAG_SIZE</div><div class="ttdef"><b>Definition:</b> fragmenter.h:157</div></div>
<div class="ttc" id="astructschc__fragmentation__t_html_af8670ae896636ff443e1079940ba018c"><div class="ttname"><a href="structschc__fragmentation__t.html#af8670ae896636ff443e1079940ba018c">schc_fragmentation_t::MAX_WND_FCN</a></div><div class="ttdeci">uint8_t MAX_WND_FCN</div><div class="ttdef"><b>Definition:</b> fragmenter.h:153</div></div>
<div class="ttc" id="astructschc__rule_html_af5f20076e164f0bbeaf3f2fbbab1ee78"><div class="ttname"><a href="structschc__rule.html#af5f20076e164f0bbeaf3f2fbbab1ee78">schc_rule::length</a></div><div class="ttdeci">uint8_t length</div><div class="ttdef"><b>Definition:</b> config.h:56</div></div>
<div class="ttc" id="acompressor_8c_html_abd42f4bd7b7fdd8ea7b4c3504720a0ea"><div class="ttname"><a href="compressor_8c.html#abd42f4bd7b7fdd8ea7b4c3504720a0ea">schc_compress</a></div><div class="ttdeci">int16_t schc_compress(const uint8_t *data, uint8_t *buf, uint16_t total_length)</div><div class="ttdoc">Compresses a CoAP/UDP/IP packet.</div><div class="ttdef"><b>Definition:</b> compressor.c:1320</div></div>
<div class="ttc" id="astructschc__mbuf__t_html"><div class="ttname"><a href="structschc__mbuf__t.html">schc_mbuf_t</a></div><div class="ttdef"><b>Definition:</b> fragmenter.h:60</div></div>
<div class="ttc" id="astructschc__field_html_a935adff07534f10568676ffa884ea4aa"><div class="ttname"><a href="structschc__field.html#a935adff07534f10568676ffa884ea4aa">schc_field::field_length</a></div><div class="ttdeci">uint8_t field_length</div><div class="ttdef"><b>Definition:</b> config.h:40</div></div>
<div class="ttc" id="astructschc__rule_html"><div class="ttname"><a href="structschc__rule.html">schc_rule</a></div><div class="ttdef"><b>Definition:</b> config.h:52</div></div>
<div class="ttc" id="astructschc__device_html_a15834e0951fb90004fc75760cc43109a"><div class="ttname"><a href="structschc__device.html#a15834e0951fb90004fc75760cc43109a">schc_device::udp_count</a></div><div class="ttdeci">uint8_t udp_count</div><div class="ttdef"><b>Definition:</b> config.h:64</div></div>
<div class="ttc" id="astructschc__fragmentation__t_html_af72b38948d4bb6fbc0a261cd092ddd10"><div class="ttname"><a href="structschc__fragmentation__t.html#af72b38948d4bb6fbc0a261cd092ddd10">schc_fragmentation_t::FCN_SIZE</a></div><div class="ttdeci">uint8_t FCN_SIZE</div><div class="ttdef"><b>Definition:</b> fragmenter.h:151</div></div>
<div class="ttc" id="astructschc__device_html"><div class="ttname"><a href="structschc__device.html">schc_device</a></div><div class="ttdef"><b>Definition:</b> config.h:60</div></div>
<div class="ttc" id="astructschc__device_html_ad2762cbab006c80cc2ffebe131e327ea"><div class="ttname"><a href="structschc__device.html#ad2762cbab006c80cc2ffebe131e327ea">schc_device::coap_count</a></div><div class="ttdeci">uint8_t coap_count</div><div class="ttdef"><b>Definition:</b> config.h:66</div></div>
<div class="ttc" id="astructschc__field_html_ac630b87f129d988ad5d18d2f22375354"><div class="ttname"><a href="structschc__field.html#ac630b87f129d988ad5d18d2f22375354">schc_field::target_value</a></div><div class="ttdeci">unsigned char target_value[MAX_COAP_FIELD_LENGTH]</div><div class="ttdef"><b>Definition:</b> config.h:43</div></div>
<div class="ttc" id="astructschc__field_html_a95686cf98fe8ea0e3e613fc7b3543a9c"><div class="ttname"><a href="structschc__field.html#a95686cf98fe8ea0e3e613fc7b3543a9c">schc_field::field</a></div><div class="ttdeci">char field[32]</div><div class="ttdef"><b>Definition:</b> config.h:38</div></div>
<div class="ttc" id="afragmenter_8c_html_a6a248f74b7a8b0ef5f7dbc3f418e05a8"><div class="ttname"><a href="fragmenter_8c.html#a6a248f74b7a8b0ef5f7dbc3f418e05a8">schc_reassemble</a></div><div class="ttdeci">int8_t schc_reassemble(schc_fragmentation_t *rx_conn)</div><div class="ttdoc">the receiver state machine</div><div class="ttdef"><b>Definition:</b> fragmenter.c:1601</div></div>
<div class="ttc" id="astructschc__fragmentation__t_html_aacb88301231fdf7ebf596250d3b75201"><div class="ttname"><a href="structschc__fragmentation__t.html#aacb88301231fdf7ebf596250d3b75201">schc_fragmentation_t::mtu</a></div><div class="ttdeci">uint16_t mtu</div><div class="ttdef"><b>Definition:</b> fragmenter.h:104</div></div>
<div class="ttc" id="afragmenter_8c_html_a0fac20e73f52464091a717bde243deb3"><div class="ttname"><a href="fragmenter_8c.html#a0fac20e73f52464091a717bde243deb3">schc_input</a></div><div class="ttdeci">schc_fragmentation_t * schc_input(uint8_t *data, uint16_t len, schc_fragmentation_t *tx_conn, uint32_t device_id)</div><div class="ttdoc">This function should be called whenever a packet is received.</div><div class="ttdef"><b>Definition:</b> fragmenter.c:2341</div></div>
<div class="ttc" id="afragmenter_8c_html_a8d563c2c366a59b52ae25123a38c7603"><div class="ttname"><a href="fragmenter_8c.html#a8d563c2c366a59b52ae25123a38c7603">schc_fragmenter_init</a></div><div class="ttdeci">int8_t schc_fragmenter_init(schc_fragmentation_t *tx_conn, void(*send)(uint8_t *data, uint16_t length, uint32_t device_id), void(*end_rx)(schc_fragmentation_t *conn), void(*remove_timer_entry)(uint32_t device_id))</div><div class="ttdoc">Initializes the SCHC fragmenter.</div><div class="ttdef"><b>Definition:</b> fragmenter.c:1946</div></div>
<div class="ttc" id="afragmenter_8c_html_a3b3e7a45b2ff0f407adfcc266f47c3dc"><div class="ttname"><a href="fragmenter_8c.html#a3b3e7a45b2ff0f407adfcc266f47c3dc">mbuf_copy</a></div><div class="ttdeci">void mbuf_copy(schc_mbuf_t *head, uint8_t *ptr)</div><div class="ttdoc">copy the byte alligned contents of the mbuf chain to the passed pointer</div><div class="ttdef"><b>Definition:</b> fragmenter.c:526</div></div>
<div class="ttc" id="astructschc__fragmentation__t_html_ac3fbcae2ee4198df9d04438d63d97361"><div class="ttname"><a href="structschc__fragmentation__t.html#ac3fbcae2ee4198df9d04438d63d97361">schc_fragmentation_t::dc</a></div><div class="ttdeci">uint32_t dc</div><div class="ttdef"><b>Definition:</b> fragmenter.h:106</div></div>
<div class="ttc" id="astructschc__field_html_af44027e5add508a163aef5a0898bbb15"><div class="ttname"><a href="structschc__field.html#af44027e5add508a163aef5a0898bbb15">schc_field::field_pos</a></div><div class="ttdeci">uint8_t field_pos</div><div class="ttdef"><b>Definition:</b> config.h:41</div></div>
<div class="ttc" id="aconfig_8h_html_a99f26e6ee9fcd62f75203b5402df8098"><div class="ttname"><a href="config_8h.html#a99f26e6ee9fcd62f75203b5402df8098">direction</a></div><div class="ttdeci">direction</div><div class="ttdef"><b>Definition:</b> config.h:22</div></div>
<div class="ttc" id="afragmenter_8c_html_a5c375e7b44652a0eccb9248083a6251d"><div class="ttname"><a href="fragmenter_8c.html#a5c375e7b44652a0eccb9248083a6251d">schc_fragment</a></div><div class="ttdeci">int8_t schc_fragment(schc_fragmentation_t *tx_conn)</div><div class="ttdoc">the sender state machine</div><div class="ttdef"><b>Definition:</b> fragmenter.c:2117</div></div>
<div class="ttc" id="astructschc__fragmentation__t_html"><div class="ttname"><a href="structschc__fragmentation__t.html">schc_fragmentation_t</a></div><div class="ttdef"><b>Definition:</b> fragmenter.h:92</div></div>
<div class="ttc" id="astructschc__fragmentation__t_html_af54664c2e4cfb10cc250896f070f6d5b"><div class="ttname"><a href="structschc__fragmentation__t.html#af54664c2e4cfb10cc250896f070f6d5b">schc_fragmentation_t::post_timer_task</a></div><div class="ttdeci">void(* post_timer_task)(void(*timer_task)(void *conn), uint32_t device_id, uint32_t time_ms, void *arg)</div><div class="ttdef"><b>Definition:</b> fragmenter.h:132</div></div>
<div class="ttc" id="acompressor_8c_html_a650a861e13b9cb68043df5319d83b92d"><div class="ttname"><a href="compressor_8c.html#a650a861e13b9cb68043df5319d83b92d">compute_length</a></div><div class="ttdeci">uint16_t compute_length(unsigned char *data, uint16_t data_len)</div><div class="ttdoc">Set the packet length for the UDP and IP headers.</div><div class="ttdef"><b>Definition:</b> compressor.c:1501</div></div>
<div class="ttc" id="astructschc__fragmentation__t_html_a5233caff42cce7f50dd5279b9d838400"><div class="ttname"><a href="structschc__fragmentation__t.html#a5233caff42cce7f50dd5279b9d838400">schc_fragmentation_t::WINDOW_SIZE</a></div><div class="ttdeci">uint8_t WINDOW_SIZE</div><div class="ttdef"><b>Definition:</b> fragmenter.h:155</div></div>
<div class="ttc" id="aconfig_8h_html_a3e43f38d5254d1e3bbf1d0955eb98ce4"><div class="ttname"><a href="config_8h.html#a3e43f38d5254d1e3bbf1d0955eb98ce4">CDA</a></div><div class="ttdeci">CDA</div><div class="ttdef"><b>Definition:</b> config.h:26</div></div>
<div class="ttc" id="acompressor_8c_html_a4fd03f3acd56b4bf55fc4c8e48567ab7"><div class="ttname"><a href="compressor_8c.html#a4fd03f3acd56b4bf55fc4c8e48567ab7">schc_compressor_init</a></div><div class="ttdeci">uint8_t schc_compressor_init(uint8_t src[16])</div><div class="ttdoc">Initializes the SCHC compressor.</div><div class="ttdef"><b>Definition:</b> compressor.c:1303</div></div>
<div class="ttc" id="astructschc__rule_html_afd8204c9d5c8d9262ce77ff417322b3c"><div class="ttname"><a href="structschc__rule.html#afd8204c9d5c8d9262ce77ff417322b3c">schc_rule::rule_id</a></div><div class="ttdeci">uint16_t rule_id</div><div class="ttdef"><b>Definition:</b> config.h:53</div></div>
<div class="ttc" id="acompressor_8c_html_a48ebb52c79106c2a7658a513c2a65463"><div class="ttname"><a href="compressor_8c.html#a48ebb52c79106c2a7658a513c2a65463">schc_construct_header</a></div><div class="ttdeci">uint16_t schc_construct_header(unsigned char *data, unsigned char *header, uint32_t device_id, uint16_t total_length, uint8_t *header_offset)</div><div class="ttdoc">Construct the header from the layered set of rules.</div><div class="ttdef"><b>Definition:</b> compressor.c:1403</div></div>
<div class="ttc" id="astructschc__fragmentation__t_html_a81a06b0db6f570800959533e1fd2ce58"><div class="ttname"><a href="structschc__fragmentation__t.html#a81a06b0db6f570800959533e1fd2ce58">schc_fragmentation_t::packet_len</a></div><div class="ttdeci">uint16_t packet_len</div><div class="ttdef"><b>Definition:</b> fragmenter.h:96</div></div>
<div class="ttc" id="astructschc__rule_html_aead6af025477ce0b7c180b9df5091057"><div class="ttname"><a href="structschc__rule.html#aead6af025477ce0b7c180b9df5091057">schc_rule::down</a></div><div class="ttdeci">uint8_t down</div><div class="ttdef"><b>Definition:</b> config.h:55</div></div>
<div class="ttc" id="astructschc__fragmentation__t_html_ab0679bb4a377f6ce9da82769cf88c52c"><div class="ttname"><a href="structschc__fragmentation__t.html#ab0679bb4a377f6ce9da82769cf88c52c">schc_fragmentation_t::mode</a></div><div class="ttdeci">reliability_mode mode</div><div class="ttdef"><b>Definition:</b> fragmenter.h:147</div></div>
<div class="ttc" id="astructschc__device_html_a5f22593142303b2722a0b9fb4167949e"><div class="ttname"><a href="structschc__device.html#a5f22593142303b2722a0b9fb4167949e">schc_device::id</a></div><div class="ttdeci">uint32_t id</div><div class="ttdef"><b>Definition:</b> config.h:61</div></div>
<div class="ttc" id="astructschc__device_html_a48b4d7fc260918b615608790b7913fcc"><div class="ttname"><a href="structschc__device.html#a48b4d7fc260918b615608790b7913fcc">schc_device::ipv6_rules</a></div><div class="ttdeci">const struct schc_rule * ipv6_rules</div><div class="ttdef"><b>Definition:</b> config.h:63</div></div>
<div class="ttc" id="aschc__config_8h_html_af1690024e8fe24a690d86ec4dd5d3bb6"><div class="ttname"><a href="schc__config_8h.html#af1690024e8fe24a690d86ec4dd5d3bb6">COAP_FIELDS</a></div><div class="ttdeci">#define COAP_FIELDS</div><div class="ttdef"><b>Definition:</b> schc_config.h:31</div></div>
<div class="ttc" id="astructschc__device_html_a2a3b02f0e0c66aea96fb08a64fa8b77f"><div class="ttname"><a href="structschc__device.html#a2a3b02f0e0c66aea96fb08a64fa8b77f">schc_device::coap_rules</a></div><div class="ttdeci">const struct schc_rule * coap_rules</div><div class="ttdef"><b>Definition:</b> config.h:67</div></div>
<div class="ttc" id="aschc__config_8h_html_aa6420ecddb30151dd25bc1a2da3aacd1"><div class="ttname"><a href="schc__config_8h.html#aa6420ecddb30151dd25bc1a2da3aacd1">MAX_COAP_FIELD_LENGTH</a></div><div class="ttdeci">#define MAX_COAP_FIELD_LENGTH</div><div class="ttdef"><b>Definition:</b> schc_config.h:35</div></div>
<div class="ttc" id="astructschc__device_html_a29183298f7685ea9e6e88e0f72902b9c"><div class="ttname"><a href="structschc__device.html#a29183298f7685ea9e6e88e0f72902b9c">schc_device::udp_rules</a></div><div class="ttdeci">const struct schc_rule * udp_rules</div><div class="ttdef"><b>Definition:</b> config.h:65</div></div>
<div class="ttc" id="afragmenter_8h_html_a00b61f9b90ab7065eb6a978141d7fd34abb669910db44bb35ca22cfa0987cff5f"><div class="ttname"><a href="fragmenter_8h.html#a00b61f9b90ab7065eb6a978141d7fd34abb669910db44bb35ca22cfa0987cff5f">ACK_ON_ERROR</a></div><div class="ttdef"><b>Definition:</b> fragmenter.h:54</div></div>
<div class="ttc" id="astructschc__rule_html_a8f5dabb53d4bd4cfa409a2b56faef7d0"><div class="ttname"><a href="structschc__rule.html#a8f5dabb53d4bd4cfa409a2b56faef7d0">schc_rule::content</a></div><div class="ttdeci">struct schc_field content[COAP_FIELDS]</div><div class="ttdef"><b>Definition:</b> config.h:57</div></div>
<div class="ttc" id="astructschc__device_html_a5083555c2c2ccf7596ff712a5f553164"><div class="ttname"><a href="structschc__device.html#a5083555c2c2ccf7596ff712a5f553164">schc_device::ipv6_count</a></div><div class="ttdeci">uint8_t ipv6_count</div><div class="ttdef"><b>Definition:</b> config.h:62</div></div>
<div class="ttc" id="acompressor_8c_html_a89368d1a9e14855697684aa89b0f1aac"><div class="ttname"><a href="compressor_8c.html#a89368d1a9e14855697684aa89b0f1aac">compute_checksum</a></div><div class="ttdeci">uint16_t compute_checksum(unsigned char *data)</div><div class="ttdoc">Calculates the UDP checksum and sets the appropriate header fields.</div><div class="ttdef"><b>Definition:</b> compressor.c:1557</div></div>
<div class="ttc" id="afragmenter_8c_html_a974581b10381381bafe401fc2ddc54c7"><div class="ttname"><a href="fragmenter_8c.html#a974581b10381381bafe401fc2ddc54c7">get_mbuf_len</a></div><div class="ttdeci">uint16_t get_mbuf_len(schc_mbuf_t *head)</div><div class="ttdoc">returns the total length of the mbuf</div><div class="ttdef"><b>Definition:</b> fragmenter.c:485</div></div>
<div class="ttc" id="astructschc__fragmentation__t_html_a8a6c636f8d863fc3db680da64ee889c1"><div class="ttname"><a href="structschc__fragmentation__t.html#a8a6c636f8d863fc3db680da64ee889c1">schc_fragmentation_t::RULE_SIZE</a></div><div class="ttdeci">uint8_t RULE_SIZE</div><div class="ttdef"><b>Definition:</b> fragmenter.h:149</div></div>
<div class="ttc" id="astructschc__field_html_a29edf1bbed3c31adec3a364ab55389ed"><div class="ttname"><a href="structschc__field.html#a29edf1bbed3c31adec3a364ab55389ed">schc_field::msb_length</a></div><div class="ttdeci">uint8_t msb_length</div><div class="ttdef"><b>Definition:</b> config.h:39</div></div>
<div class="ttc" id="astructschc__field_html_a53b37bd9de93614e76640174cffa11fa"><div class="ttname"><a href="structschc__field.html#a53b37bd9de93614e76640174cffa11fa">schc_field::action</a></div><div class="ttdeci">CDA action</div><div class="ttdef"><b>Definition:</b> config.h:45</div></div>
<div class="ttc" id="astructschc__field_html_a23f0e54fa507136cff38e313b3f064cb"><div class="ttname"><a href="structschc__field.html#a23f0e54fa507136cff38e313b3f064cb">schc_field::dir</a></div><div class="ttdeci">direction dir</div><div class="ttdef"><b>Definition:</b> config.h:42</div></div>
<div class="ttc" id="astructschc__field_html"><div class="ttname"><a href="structschc__field.html">schc_field</a></div><div class="ttdef"><b>Definition:</b> config.h:37</div></div>
<div class="ttc" id="afragmenter_8c_html_af04b125eaaa72e66f782bdb592133a27"><div class="ttname"><a href="fragmenter_8c.html#af04b125eaaa72e66f782bdb592133a27">schc_reset</a></div><div class="ttdeci">void schc_reset(schc_fragmentation_t *conn)</div><div class="ttdoc">reset a connection</div><div class="ttdef"><b>Definition:</b> fragmenter.c:978</div></div>
<div class="ttc" id="astructschc__fragmentation__t_html_a0d771b7ddff550f4e30b238f1a332572"><div class="ttname"><a href="structschc__fragmentation__t.html#a0d771b7ddff550f4e30b238f1a332572">schc_fragmentation_t::send</a></div><div class="ttdeci">uint8_t(* send)(uint8_t *data, uint16_t length, uint32_t device_id)</div><div class="ttdef"><b>Definition:</b> fragmenter.h:130</div></div>
<div class="ttc" id="astructschc__fragmentation__t_html_a54c6634755f3b9737e8c61d0fdea3a37"><div class="ttname"><a href="structschc__fragmentation__t.html#a54c6634755f3b9737e8c61d0fdea3a37">schc_fragmentation_t::data_ptr</a></div><div class="ttdeci">uint8_t * data_ptr</div><div class="ttdef"><b>Definition:</b> fragmenter.h:98</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
